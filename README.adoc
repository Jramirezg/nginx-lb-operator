= NGINX Controller Operator
:showtitle:
:toc: left

== Operator SDK
This Operator was built with the operator SDK. Follow these install instructions...

https://sdk.operatorframework.io/docs/install-operator-sdk/[https://sdk.operatorframework.io/docs/install-operator-sdk/]

== Codeready Containers Setup

=== Trust CRC Repo

First trust make docker trust the certificate from your CRC repo. Get the cert with:

----
oc extract secret/router-ca --keys=tls.crt -n openshift-ingress-operator --confirm --to=-
----

On Debian/Ubuntu you can make the OS trust the Cert by adding it to you ca-certificates

----
oc extract secret/router-ca --keys=tls.crt -n openshift-ingress-operator --confirm --to=- | sudo tee /usr/local/share/ca-certificates/crc-router.crt
sudo update-ca-certificates
----

Then login to the repo

----
docker login -p $(oc whoami -t) -u unused default-route-openshift-image-registry.apps-crc.testing
----

== Build the Operator 

These instructions assume you are using the OCP 4.x image-repository in CRC. Change the image name if you're deploying
onto a real OCP environment

=== Store image in same project

We need the OCP project to exist first, else we can't upload images for it.
----
oc new-project lb-nginx-com
----

build and push to our new project.

----
export IMAGE=default-route-openshift-image-registry.apps-crc.testing/lb-nginx-com/nginx-lb-operator:latest
operator-sdk build $IMAGE
docker push $IMAGE
----

=== Store image in different project (eg default)

Alternatively you can push to the default project (or any other project) as long as your project has access.

Enable cross namespace repo access with:

----
oc policy add-role-to-group registry-viewer system:serviceaccounts:<consumer> --namespace=<publisher>
----

Eg:

----
oc policy add-role-to-group registry-viewer system:serviceaccounts:lb-nginx-com --namespace=default
----

Then push to default (or other) project...

----
export IMAGE=default-route-openshift-image-registry.apps-crc.testing/default/nginx-lb-operator:latest
operator-sdk build $IMAGE
docker push $IMAGE
----

You can ofcourse build and push to an extneral docker registry too ;-)

== Install the CRDs

----
oc create -f deploy/crds/lb.nginx.com_controllers_crd.yaml
oc create -f deploy/crds/lb.nginx.com_applications_crd.yaml
oc create -f deploy/crds/lb.nginx.com_components_crd.yaml
oc create -f deploy/crds/lb.nginx.com_gateways_crd.yaml
----

== Deploy the Operator

The Operator is namespace-scoped, so each project needs to run it's own operator. It might make more
sense to deploy as a cluster-scoped operator, but for now it per namespace.

Check that you're on the correct project, and then deploy the operator

----
export IMAGE=image-registry.openshift-image-registry.svc:5000/default/nginx-lb-operator:latest
sed -e "s|REPLACE_IMAGE|${IMAGE}|g" deploy/operator.yaml > deploy/operator-for-reals.yaml
oc create -f deploy/service_account.yaml
oc create -f deploy/role.yaml
oc create -f deploy/role_binding.yaml
oc create -f deploy/operator-for-reals.yaml
----

== Managing NGINX Configs

After deploying the operator it will start watching for new instances of the CRDs. There are
currently 5 CRDs, and 4 of them are watched.

.CRDs
|===
| CRD | Description | Watched

| lb.nginx.com_controllers
| Controller Configuration, Includes FQDN, Auth details, and the Environment to use.
| No

| lb.nginx.com_applications
| The Application as represented in NGINX Controller
| Yes

| lb.nginx.com_gateways
| A Service gateway, The NGINX instances on which components will be deployed
| Yes

| lb.nginx.com_components
| The component is deployed into and application on a gateway
| Yes

| lb.nginx.com_certificates
| Coming Soon
| Yes
|===

The controller needs to be configured first.

=== Controller CRD

The controller CRD take a user_email, FQDN, and Environment. It also needs a password stored in a Kubernetes Secret

Such as: 

[source,yaml]
----
kind: Secret
apiVersion: v1
metadata:
  name: dev-controller
data:
  user_password: bm90cmVhbGx5bXlwYXNzd29yZAo=
type: Opaque
----

The secret will be updated by the operator with an oath_token and a login_timestamp. The Operator will reuse the oath token for
30 minutes, after which it will perform a new login.

A controller object using the above secret would look like this:

[source,yaml]
----
apiVersion: lb.nginx.com/v1alpha1
kind: Controller
metadata:
  name: dev-controller
spec:
  user_email: "admin@nginx.com"
  secret: "dev-controller"
  fqdn: "ctrl.nginx.lab"
  environment: "ocp-dev-1"
  validate_certs: true
----

The user account and the environment should already exist on the controller. All Applications, Gateways, Components, and Certificates
will reference a controller object by name and be deployed into the environment specified.

=== Application CRD

The Application is a simple object, but it groups the components and helps with analytics visualisation

[source,yaml]
----
apiVersion: lb.nginx.com/v1alpha1
kind: Application
metadata:
  name: my-application
spec:
  controller: "dev-controller"
  displayName: "My Kubernetes Application"
  description: "An application deployed in Kubernetes"
----

=== Gateway CRD

The Gateways object takes a `desiredState` whch is sent to controller as is, so you can enable
any features exposed in the Controller API. Check your controller API for more information.

[source,yaml]
----
apiVersion: lb.nginx.com/v1alpha1
kind: Gateway
metadata:
  name: my-gateway
spec:
  controller: "dev-controller"
  displayName: "My OCP Gateway"
  description: "A gateway deployed by Kubernetes"
  desiredState:
    ingress:
      placement:
        instancerefs:
          - ref: /infrastructure/locations/unspecified/instances/6
      uris:
        'http://www.uk.nginx.lab': {}
        'http://www.foo.com': {}
----

=== Component CRD

The Component object also takes a `desiredState`, but the operator expects to configure both the `ingress->gatewayRefs` 
using the `gateway` provided, and the `backend->workloadGroups->group` using the pods or NodePorts found in the `ingress`
setting. The workload `uris` are built using `workload.scheme` and `workload.path`

[source,yaml]
----
apiVersion: lb.nginx.com/v1alpha1
kind: Component
metadata:
  name: my-component
spec:
  controller: "dev-controller"
  application: "my-application"
  ingress: "my-nginx-ingress-controller"
  gateway: "my-gateway"
  workload:
    scheme: "http"
    path: "/"
    targetPort: 443
    crcOverride: 192.168.130.11
  displayName: "My Component"
  description: "A component deployed by Kubernetes"
  desiredState:
    backend:
      monitoring:
        response:
          status:
            match: true
            range:
              endCode: 302
              startCode: 200
        uri: /
      workloadGroups:
        # group uris will be populated from "ingress" pods or nodeports
        group:
          loadBalancingMethod:
            type: ROUND_ROBIN
    # ingress gatewayRefs will be populated from "gateway"
    ingress:
      uris:
        /: {}
----

The above would result in a `desiredState` similar to:

[source,json]
----
  "desiredState": {
    "ingress": {
      "gatewayRefs": [
        {
          "ref": "/services/environments/ocp-dev-1/gateways/<project>.my-gateway"
        }
      ],
      "uris": {
        "/": {}
      }
    },
    "backend": {
      "workloadGroups": {
        "group": {
          "loadBalancingMethod": {
            "type": "ROUND_ROBIN"
          },
          "uris": {
            "http://<k8s-node-ip>:<nodeport>/": { }
          }
        }
      },
      "monitoring": {
        "uri": "/",
        "response": {
          "status": {
            "range": {
              "endCode": 302,
              "startCode": 200
            },
            "match": true
          }
        }
      }
    }
  }
----

=== Certificate CRD

The certificate Resource can be specified either by providing the details in the object directly
within the `desiredState` or by referencing a Kubernetes Secret in `secret`.

----
apiVersion: lb.nginx.com/v1alpha1
kind: Certificate
metadata:
  name: my-certificate
spec:
  controller: "dev-controller"
  displayName: "My Kubernetes Certificate"
  description: "A certificated deployed in Kubernetes"
  #secret: secret-containing-the-cert
  desiredState:
    type: PEM
    caCerts: []
    privateKey: |-
      -----BEGIN PRIVATE KEY-----
      MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDQYBXFTj1ZdJGH
      7IfomkeJfedaIueD01L6X6jj8TvS2xwTRHL4LIkZP882qHs2VfEpgbVi6a96lvWP
      TRUNCATED  TRUNCATED  TRUNCATED  TRUNCATED  TRUNCATED  TRUNCATED
      6bug7eceyafsFTTEghcNloHWnYBARA3878X5RQkLVUNocrZLkBG2Dn2d3aiEpWww
      CZ+gbhraYKAflzD6wTJL29D5dLGF5k/88RTN60Gzoaxq7CkvlLwXCZjQSvjEGq5i
      whJYgXwWvqy5VXxLc5amLXk=
      -----END PRIVATE KEY-----
    publicCert: |-
      -----BEGIN CERTIFICATE-----
      MIIDpzCCAo+gAwIBAgIUb+NqxHIP0Z15aqy5FY8+bb1vq6IwDQYJKoZIhvcNAQEL
      1Xnimah+mQMOuWiJU9W9omet5Y9OemQLHmeSVFbfQXBkTNKGO+2iKtWJNO8+zzT7
      TRUNCATED  TRUNCATED  TRUNCATED  TRUNCATED  TRUNCATED  TRUNCATED
      5WZTPiggaDbDAwjK2QP2N933lHxR5JDmkHHH6GHKLWXgYgxY0zx8R2+eFyvxJvGB
      yaw7SnX8i5mjkgwwGhgTMBnSdf3F9eLcMHPgceMOuTyynpe9SSE9Bck3LykgvQDW
      InWB8mhlndb/p8ZYVLx9y2LDq1h3iymbnoHM
      -----END CERTIFICATE-----
----

When referencing the cert as a kubernetes secret, then it should be an Opaque type and
the certificate details should be stored in `tls.key` and `tls.crt`. 

----
kind: Secret
apiVersion: v1
metadata:
  name: my-cert
data:
  tls.crt: >-
    LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURwekNDQW8rZ0F3SUJBZ0lVYitOcXhISVAw
  tls.key: >-
    LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2UUlCQURBTkJna3Foa2lHOXcwQkFRRUZB
  type: UEVN
type: Opaque
----

and the Certificate would look like this

----
apiVersion: lb.nginx.com/v1alpha1
kind: Certificate
metadata:
  name: my-certificate
spec:
  controller: "dev-controller"
  displayName: "My Kubernetes Certificate"
  description: "A certificated deployed in Kubernetes"
  secret: my-cert
----

